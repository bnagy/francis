# BEGIN LICENSE ###
# Use of the triage tools and related source code is subject to the terms
# of the license below.
#
# ------------------------------------------------------------------------
# Copyright (C) 2011 Carnegie Mellon University. All Rights Reserved.
# Portions Copyright 2013 BlackBerry Ltd. All Rights Reserved.
# ------------------------------------------------------------------------
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following acknowledgments
#    and disclaimers.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. All advertising materials for third-party software mentioning
#    features or use of this software must display the following
#    disclaimer:
#
#    "Neither Carnegie Mellon University nor its Software Engineering
#     Institute have reviewed or endorsed this software"
#
# 4. The names "Department of Homeland Security," "Carnegie Mellon
#    University," "CERT" and/or "Software Engineering Institute" shall
#    not be used to endorse or promote products derived from this software
#    without prior written permission. For written permission, please
#    contact permission@sei.cmu.edu.
#
# 5. Products derived from this software may not be called "CERT" nor
#    may "CERT" appear in their names without prior written permission of
#    permission@sei.cmu.edu.
#
# 6. Redistributions of any form whatsoever must retain the following
#    acknowledgment:
#
#    "This product includes software developed by CERT with funding
#     and support from the Department of Homeland Security under
#     Contract No. FA 8721-05-C-0003."
#
# THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND
# CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER
# EXPRESS OR IMPLIED, AS TO ANY MATTER, AND ALL SUCH WARRANTIES, INCLUDING
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, ARE
# EXPRESSLY DISCLAIMED. WITHOUT LIMITING THE GENERALITY OF THE FOREGOING,
# CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND
# RELATING TO EXCLUSIVITY, INFORMATIONAL CONTENT, ERROR-FREE OPERATION,
# RESULTS TO BE OBTAINED FROM USE, FREEDOM FROM PATENT, TRADEMARK AND
# COPYRIGHT INFRINGEMENT AND/OR FREEDOM FROM THEFT OF TRADE SECRETS.
# END LICENSE ###
'''
Contains analyzers used to match rules that are used to classify the state
of a LLDB inferior and some helper functions.
'''

import re
import signal
import os
import platform
import sys
import commands
import struct

from lib.tools import memoized

# TODO - DRY this snippet
# ----------------------------------------------------------------------
# Code that auto imports LLDB
# ----------------------------------------------------------------------
try:
    # Just try for LLDB in case PYTHONPATH is already correctly setup
    import lldb
except ImportError:
    lldb_python_dirs = list()
    # lldb is not in the PYTHONPATH, try some defaults for the current platform
    platform_system = platform.system()
    if platform_system == 'Darwin':
        # On Darwin, try the currently selected Xcode directory
        xcode_dir = commands.getoutput("xcode-select --print-path")
        if xcode_dir:
            lldb_python_dirs.append(os.path.realpath(xcode_dir + '/../SharedFrameworks/LLDB.framework/Resources/Python'))
            lldb_python_dirs.append(xcode_dir + '/Library/PrivateFrameworks/LLDB.framework/Resources/Python')
        lldb_python_dirs.append('/System/Library/PrivateFrameworks/LLDB.framework/Resources/Python')
    success = False
    for lldb_python_dir in lldb_python_dirs:
        if os.path.exists(lldb_python_dir):
            if not (sys.path.__contains__(lldb_python_dir)):
                sys.path.append(lldb_python_dir)
                try:
                    import lldb
                except ImportError:
                    pass
                else:
                    success = True
                    break
    if not success:
        print "error: couldn't locate the 'lldb' module, please set PYTHONPATH correctly"
        sys.exit(1)

try:
    from termcolor import colored
except ImportError:
    def colored(s, color):
        return s

PAGE_SIZE = 4096
QUITE_CLOSE = 1024
SANE_STACK_SIZE = 400  # matches CW recursive_write test
R_ALNUMSPACE = re.compile('[^\w\s]+')


class Analyzer(object):
    '''
    Contains methods that analyze a Target (an OSX LLDB inferior state) to
    determine properties of the Target (such as how the application crashed).
    '''

    # CHANGES ( bn )
    #
    # I've removed all the compounded methods that correspond
    # to the rules.py they used in jfoote/exploitable in favour of just
    # supplying "indicators" than can be combined by higher-level triage
    # tools. That simplifies this code and allows more granular triage and
    # post-processing ( indicators are preserved in the crash information
    # metadata instead of being lost in favour of a single classification )
    #
    # I've stripped a lot of the scaffolding that was used to make the GDB
    # version work as a plugin inside GDB, in favour of making this a simple
    # LLDB standalone tool using the python/SWIG API. This has both good and
    # bad implications, but it's a lot easier to write. Hopefully it can still
    # be folded back into mainline somehow.
    def __init__(self, target, no_color):
        global colored
        if no_color:
            def colored(s, color):
                return s
        self.target = target
        self.stack_huge = None
        self.process = target.process
        self.thread = target.process.selected_thread
        # SBAddress, can use self.GetLoadAddress(self.target) if required
        self.pc = self.thread.GetFrameAtIndex(0).GetPCAddress()
        if not self.process or not self.process.IsValid() \
           or not self.thread or not self.thread.IsValid():
            # pc is allowed to be invalid, natch
            raise ValueError('No process / thread in target!')
        triple = target.GetTriple()

        (g_arch, manufacturer, platform) = triple.split('-')

        if g_arch == 'x86' or g_arch == 'arm':
            self.width = 4
        elif g_arch == 'x86_64':
            self.width = 8
    # ---
    # INDICATORS
    # ---

    @memoized
    def isSuspiciousAv(self):
        if not self.isAv:
            return False
        # CW check.
        if abs(self.faultingAddress - 0x55555555) < QUITE_CLOSE:
            # The access address indicates the use of freed memory if MallocScribble
            # was used, or uninitialized memory if libgmalloc and MALLOC_FILL_SPACE was used.
            return True
        elif abs(self.faultingAddress - 0xaaaaaaaa) < QUITE_CLOSE:
            # The access address indicates that uninitialized memory
            # was being used if MallocScribble was used
            return True
        elif abs(self.faultingAddress - 0x41414141) < QUITE_CLOSE:
            # you never know ;)
            return True
        else:
            return False

    @memoized
    def isIllegalInstruction(self):
        # OSX - Bad syscall is SIGSYS, bad instruction is EXC_BAD_INSTRUCTION
        if self.isSignal():
            return self.isSignalInList(["SIGILL", "SIGSYS"])
        if self.isException():
            return self.getExceptionType() == "EXC_BAD_INSTRUCTION"
        return False

    @memoized
    def isBenign(self):
        if self.isSignal():
            return self.isBenignSignal
        elif self.isException():
            return self.isBenignException()
        else:
            return False

    @memoized
    def isAbort(self):
        # OSX seems to mostly use EXC_CRASH, but some OSS apps still throw
        # SIGABRT, so handle both styles.
        #
        # Not moved into isBenign. Aborts are a sign you're getting close. ;)
        if self.isSignal() and self.isSignalInList(["SIGABRT"]):
            return True
        elif self.isException() and self.getExceptionType == "EXC_CRASH":
            return True
        else:
            return False

    @memoized
    def getSuspiciousStackFuncs(self):
        # CW Check
        # Added __chk_fail_overflow for fortify_source - bn
        if platform.system() == 'Darwin':
            suspicious_functions = [
                " __stack_chk_fail ", " __chk_fail_overflow ", " szone_error ", " CFRelease ", " CFRetain ",
                " _CFRelease ", " _CFRetain", " malloc ", " calloc ", " realloc ", " objc_msgSend",
                " szone_free ", " free_small ", " tiny_free_list_add_ptr ", " tiny_free_list_remove_ptr ",
                " small_free_list_add_ptr ", " small_free_list_remove_ptr ", " large_entries_free_no_lock ",
                " large_free_no_lock ", " szone_batch_free ", " szone_destroy ", " free ",
                " CSMemDisposeHandle ", " CSMemDisposePtr ",
                " append_int ", " release_file_streams_for_task ", " __guard_setup ",
                " _CFStringAppendFormatAndArgumentsAux ", " WTF::fastFree ", " WTF::fastMalloc ",
                " WTF::FastCalloc ", " WTF::FastRealloc ", "  WTF::tryFastCalloc ", " WTF::tryFastMalloc ",
                " WTF::tryFastRealloc ", " WTF::TCMalloc_Central_FreeList ", " GMfree ", " GMmalloc_zone_free ",
                " GMrealloc ", " GMmalloc_zone_realloc ", " WTFCrashWithSecurityImplication "
            ]
        elif platform.system() == 'Linux':
            # TODO: should only match on these inside libc, need some double match or regexp?
            suspicious_functions = [
                "__GI_abort", "__libc_message", "malloc_printerr", "__malloc_assert"
            ]
        else:
            # TODO: catch this earlier
            print "unsupprted platform, exiting..."
            sys.exit(1)

        idx = 0
        susp_funcs = []
        while idx < SANE_STACK_SIZE:
            # This looks weird, but it's so that we can use the substring
            # matching the way the CW dev intended. For example objc_msgSend
            # is supposed to be a prefix match for objc_msgSend_vtable14,
            # whereas most of the rest are supposed to be matches that avoid
            # false positives ( eg if you tried free as a substring match )
            frame = self.thread.GetFrameAtIndex(idx)
            if not frame.IsValid():
                break
            func = " {} ".format(frame.GetFunctionName())
            for susp in suspicious_functions:
                if susp in func:
                    susp_funcs.append("%s" % (frame.name))
            idx += 1
        if idx >= SANE_STACK_SIZE:
            self.stack_huge = True

        return susp_funcs

    @memoized
    def isPcWeird(self):
        # This is a ported check from CW. The theory is that if $pc is outside
        # the range of any loaded module then we faulted executing either JIT
        # code or just random junk that happens to be executable ( trying to
        # run unmapped or NX memory would cause different matches )
        #
        # Because data executing like 0x00 0x00 is add al,%(rax) this shows up
        # more than you might think, and is easy to accidentally triage in
        # with null derefs.
        if not self.pc.IsValid():
            return True
        if not self.pc.module and not self.pc.symbol.name:
            return True
        # TODO more checks?
        return False

    @memoized
    def isSpWeird(self):
        sp, bp = self.getSPBP()
        # caters for underflow
        if sp and abs(bp - sp) > PAGE_SIZE * 10:
            return True
        if sp > bp:
            return True
        return False

    @memoized
    def isStackHuge(self):
        # written this way because the thread.frames and thread.num_frames
        # accessors walk the whole stack, which takes forever on runaway
        # recursion.
        if self.stack_huge is not None:
            # If they already called getSuspiciousStackFuncs() then we have
            # walked the stack and this property will be set
            return self.stack_huge
        idx = 0
        while idx < SANE_STACK_SIZE:
            if not self.thread.GetFrameAtIndex(idx).IsValid():
                return False
            idx += 1
        return True

    @memoized
    def isBlockMove(self):
        if not self.pc.IsValid():
            return False
        # lldb presents rep blah as
        # testBlockMoveAv.test`main + 21:
        # -> 0x100000f95:  f3     rep
        #    0x100000f96:  48 a5  movsq
        insns = self.disasmAtPc(2)
        if not insns:
            return False
        i2 = insns[1].mnemonic
        return insns[0].mnemonic == "rep" and i2.startswith("mov")

    # Semantic change here from https://github.com/jfoote/exploitable They use
    # SourceAv and DestAv but because we stole more granular access type
    # classification from CrashWrangler we can support R/W/X
    @memoized
    def isAvRead(self):
        if not self.isAv():
            return False
        return self.getAccessType(self.getCurrentInstruction()) == "read"

    @memoized
    def isAvWrite(self):
        if not self.isAv():
            return False
        return self.getAccessType(self.getCurrentInstruction()) == "write"

    @memoized
    def isAvExec(self):
        if not self.isAv():
            return False
        if self.isBranchAv():
            return True
        if self.isAvOnPc():
            return True
        # unknown is when the analyzer screwed up. Triage up so it will get looked at.
        return self.getAccessType(self.getCurrentInstruction()) == "exec" \
            or self.getAccessType(self.getCurrentInstruction()) == "unknown"

    @memoized
    def isAvRecursion(self):
        if not self.isAv():
            return False
        return self.getAccessType(self.getCurrentInstruction()) == "recursion"

    @memoized
    def isAvNearNull(self):
        if not self.isAv():
            return False
        # going to just handle the EXC_BAD_ACCESS case until I see a SIGSEGV
        exc, code, extra = self.getExceptionData()
        if exc == "EXC_BAD_ACCESS":
            if code == "EXC_I386_GPFLT":
                # These are when an address is invalid for the x64 ABI, but they
                # should not be lumped in with null derefs.
                return False
            try:
                # extra for BAD_ACCESS is the 0xaddress
                return self.isNearNull(int(extra, 16))
            except:
                print "WARNING: Malformed exception data %s %s %s" % (desc, code, extra)
                # don't know what went wrong, but don't mark it unexploitable :)
                return False

        return False

    @memoized
    def isAvNearSP(self):
        # CW check
        fa = self.faultingAddress()
        if fa:
            sp, bp = self.getSPBP()
            if not sp:
                # we're boned - triage up
                print "BUG: Failed to get stack pointer!"
                return True
            if abs(sp - fa) <= QUITE_CLOSE or abs(bp - fa) <= QUITE_CLOSE:
                return True
            if sp < fa < bp:
                # This could be a FP if the binary isn't using frame pointers
                return True

        return False

    @memoized
    def isAvBadBeef(self):
        # CW check:
        # WebCore functions call CRASH() in various assertions or if the amount to allocate was
        # too big.  CRASH writes a null byte to 0xbbadbeef.
        # BN - looks like fastmalloc does this too, but with EXC_BAD_ACCESS
        if not self.isAv():
            return False
        if not self.isException():
            return False
        if self.faultingAddress() and self.faultingAddress() == 0xbbadbeef:
            return True

        return False

    # ---
    # UTILITY METHODS
    # ---

    # Get Address Color
    def GAC(self, addr):
        def read_memory(addr, width=4):
            error = lldb.SBError()
            bytes_read = self.process.ReadMemory(addr, width, error)

            if error.Success():
                return bytes_read

            return None

        def is_value_null(addr):
            return addr == 0

        def is_value_all_ascii(addr_string):
            address_bytes = [int(addr_string[i:i+2], 16) for i in xrange(0, len(addr_string), 2)]
            return all(map(lambda x: x >= 0x20 and x <= 0x7f, address_bytes))

        def is_value_unicode_le(addr_string):
            address_bytes = [int(addr_string[i:i+4], 16) for i in xrange(0, len(addr_string), 4)]
            return all(map(lambda x: x >= 0x20 and x <= 0xff, address_bytes))

        def is_value_unicode_be(addr_string):
            address_bytes = [int(addr_string[i+2:i+4] + addr_string[i:i+2], 16) for i in xrange(0, len(addr_string), 4)]
            return all(map(lambda x: x >= 0x20 and x <= 0xff, address_bytes))

        def does_addr_point_to_ascii(addr, width=4):
            rv = read_memory(addr, width)
            if rv is None:
                return False

            bytes_array = [ord(x) for x in rv]
            return all(map(lambda x: x >= 0x20 and x <= 0x7f, bytes_array))

        def does_addr_point_to_unicode_le(addr, width=4):
            rv = read_memory(addr, width)
            if rv is None:
                return False

            word_array = struct.unpack("<" + "H" * (width / 2), rv)
            return all(map(lambda x: x >= 0x20 and x <= 0xff, word_array))

        def does_addr_point_to_unicode_be(addr, width=4):
            rv = read_memory(addr, width)
            if rv is None:
                return False

            word_array = struct.unpack(">" + "H" * (width / 2), rv)
            return all(map(lambda x: x >= 0x20 and x <= 0xff, word_array))

        def does_addr_point_to_dynamic_memory(addr, width=4):
            rv = read_memory(addr, width)
            if rv is None:
                return False

            debugger = self.target.debugger
            ci = debugger.GetCommandInterpreter()
            res = lldb.SBCommandReturnObject()
            ci.HandleCommand("image list -a 0x%x" % (addr, ), res)

            return not res.Succeeded()

        def does_addr_point_to_mapped_memory(addr, width=4):
            rv = read_memory(addr, width)
            if rv is None:
                return False

            return True

        if self.width == 4:
            addr_string = "%08x" % (addr, )
            display_address = "0x%08x" % (addr, )
        else:
            addr_string = "%016x" % (addr, )
            display_address = "0x%016x" % (addr, )

        if is_value_null(addr):
            return display_address

        if is_value_all_ascii(addr_string) or is_value_unicode_le(addr_string) or is_value_unicode_be(addr_string):
            return colored(display_address, 'red')

        if does_addr_point_to_ascii(addr, self.width) or does_addr_point_to_unicode_le(addr, self.width) or \
                does_addr_point_to_unicode_be(addr, self.width):
            return colored(display_address, 'yellow')

        if does_addr_point_to_dynamic_memory(addr, self.width):
            return colored(display_address, 'green')

        if does_addr_point_to_mapped_memory(addr, self.width):
            return colored("%s %s" % (display_address, self.target.ResolveLoadAddress(addr)), 'blue')

        return colored(display_address, 'cyan')

    @memoized
    def isBenignSignal(self):
        '''
        Return True if the current fault is a signal event and the signal is
        one of several that don't usually indicate an exploitable issue.
        '''
        if not self.isSignal():
            # if you forgot to check then we want you to triage this up not
            # down so you notice.
            return False
        # Some of these probably never happen on OSX
        # Change: put SIGFPE in here. Bad? - ben
        siglist = ["SIGTERM", "SIGINT", "SIGQUIT", "SIGKILL", "SIGHUP",
                   "SIGALRM", "SIGVTALRM", "SIGPROF", "SIGIO", "SIGURG",
                   "SIGPOLL", "SIGUSR1", "SIGUSR2", "SIGWINCH", "SIGINFO",
                   "SIGCHLD", "SIGCONT", "SIGSTOP", "SIGTSTP", "SIGFPE"]
        return self.isSignalInList(siglist)

    @memoized
    def isBenignException(self):
        '''
        Return True if the current fault is an exception which is usually
        considered benign. Right now those are EXC_ARITHMETIC, EXC_SOFTWARE,
        EXC_BREAKPOINT, and EXC_CRASH. However, EXC_CRASH should always be
        checked along with isSuspiciousStack(), to catch a variety of stack
        protection and malloc protection aborts.
        '''
        if not self.isException:
            # if you forgot to check then we want you to triage this up not
            # down so you notice.
            return False

        # CW note Re: EXC_CRASH being "benign":
        # NOTE: if this is an abort due to -fstack-protector, MallocCorruptionAbort, etc,
        # the log will later be patched so g_is_exploitable=YES
        #
        # For us that means that we can't rely on this indicator without also
        # checking isStackSuspicious()
        exceptions = ["EXC_ARITHMETIC", "EXC_SOFTWARE", "EXC_BREAKPOINT", "EXC_CRASH"]
        this_e = self.getExceptionType()
        for e in exceptions:
            if this_e == e:
                return True
        return False

    @memoized
    def isAv(self):
        '''
        Returns True if the current fault is an Access Violation
        '''
        if self.isException() and self.getExceptionType() == "EXC_BAD_ACCESS":
            return True
        elif self.isSignal() and self.isSignalInList(['SIGSEGV', 'SIGBUS']):
            # can this even happen?
            return True
        else:
            return False

    @memoized
    def isAvOnPc(self):
        '''
        Returns True if the fault is an AV at the program counter
        '''
        if self.isAv() and \
           self.faultingAddress() == self.pc.GetLoadAddress(self.target):
            return True
        return False

    @memoized
    def isBranchAv(self):
        '''
        Returns True if the fault is an AV on a branching instruction
        '''
        if not self.isAv():
            return False
        # Unlike gdb, lldb correctly treats calls as branching insructions
        return self.isJumpInstruction(self.getCurrentInstruction())

    @memoized
    def getAccessType(self, insn):
        '''
        Attempts to classify EXC_BAD_ACCESS as `read`, `write`, `exec` or
        `recursion`. Other possible string values are `<not an access violation>` and
        `unknown`.

        This algorithm is mostly a straight port of the logic from Apple's
        CrashWrangler in exc_handler.m, with a couple of tweaks.
        '''
        if self.isAvOnPc():
            return "exec"

        if not insn or not self.isAv():
            return "<not an access violation>"

        # ASSUMES ACCESS VIOLATION FROM HERE

        operands = insn.operands
        mnemonic = insn.mnemonic

        # logic ported from CrashWrangler exc_handler.m get_access_type()

        # I'm only ever interested in "is it there?" and numeric comparisons,
        # so adding one turns -1 into 0 which is falsey in python. FML.
        last_comma = operands.rfind(',') + 1
        right_paren = operands.rfind(')') + 1
        dollar = operands.find('$') + 1
        asterisk = operands.find('*') + 1
        percent = operands.find('%') + 1

        if operands.count(')') > 1:
            # There's more than one right paren, therefore it's an instruction like
            # rep/movsl     (%esi),(%edi)
            _, first, second, _ = R_ALNUMSPACE.sub('', operands).split()
            registers = self.getRegisters()
            if not registers[first]:
                raise ValueError("BUG: Failed to look up source register")
            if registers[first].value == self.faultingAddress():
                return "read"
            else:
                return "write"
        elif "call" in mnemonic:
            # If the instruction looks like call   0x1fe6 <foo> then it's due to the stack pointer
            # being out of bounds due to recursion or evil-sized variable size stack buffer
            # If it looks like call  *0x8(%eax) or call *%eax, or call (%eax) then it's exploitable
            #
            # TODO - I am not sure you ever want to treat fault-on-call as
            # anything but exploitable. Am I wrong? Does this encourage that? - bn
            if not right_paren and not asterisk:  # optimize for common case
                return "recursion"
            elif self.isAvNearSP():
                return "recursion"
            else:
                return "exec"
        elif "cmp" in mnemonic or "test" in mnemonic or "fld" in mnemonic:
            # These instructions are always reads, even when the right operand is the one being dereferenced.
            return "read"
        elif "fst" in mnemonic:
            return "write"  # floating point store
        elif "mov" in mnemonic and not right_paren and not dollar and percent and last_comma:
            # if there is no parenthesis and no dollar sign then it is
            # something like mov    0x41414141,%eax which is deferencing the
            # constant first argument.
            if percent > last_comma:
                return "read"
            else:
                return "write"

        elif last_comma and right_paren:
            # it has 2 operands and an explicit dereference
            if right_paren < last_comma:
                return "read"
            else:
                return "write"

        elif mnemonic.startswith('j'):  # CHANGE: any AV at a jmp is exec? - bn
            return "exec"
        elif "push" in mnemonic:
            # push (%eax) might mean crashing reading eax, or crashing writing to (%esp)
            # push eax crashing would always mean crashing writing to (%esp)
            if right_paren:
                return "read"  # probably, anyways. (YOLO - bn)
            else:
                return "recursion"

        elif "inc" in mnemonic or "dec" in mnemonic:
            # increment or decrement instructions.  Example: inc (%eax)
            # inc %eax would never crash, so we must be writing to memory.
            return "write"
        elif "stos" in mnemonic:
            return "write"
        elif "lods" in mnemonic:
            return "read"
        elif "rep" in mnemonic:  # ADDED: rep prefix with bad rdi is a nope - bn
            registers = self.getRegisters(['rsi', 'rdi'])
            if len(registers) < 2:
                return "unknown"
            if registers['rdi'] and registers['rdi'] == self.faultingAddress():
                return "write"
            else:
                return "read"
        else:
            return "unknown"
        # TODO: other instructions which take one operand and might cause a crash?

    @memoized
    def isNearNull(self, addr):
        '''
        Returns True if addr is near NULL, False otherwise
        '''
        if addr < 16 * PAGE_SIZE:  # same as !exploitable
            return True
        return False

    @memoized
    def getInsnRegisters(self, insn):
        '''
        Takes an SBInstruction object, returns a dict of 'register_name' =>
        '0xvalue' for registers used by that instruction (based on very simplistic string
        parsing, don't get excited)
        '''
        if not insn or not insn.IsValid():
            return {}
        tokens = R_ALNUMSPACE.sub('', insn.operands).split()
        registers = self.getRegisters()
        involved = {}
        for t in tokens:
            if t in registers:
                    involved[t] = "0x%.16x" % registers[t]
        return involved

    @memoized
    def getStopDescription(self):
        '''
        Returns the LLDB string description for the stop reason, eg
        EXC_BREAKPOINT (code=EXC_I386_BPT, subcode=0x0)
        '''
        return self.thread.GetStopDescription(1024)

    @memoized
    def isSignal(self):
        '''
        Returns True if the current thread is stopped due to a signal
        '''
        return self.thread.stop_reason == lldb.eStopReasonSignal

    @memoized
    def isException(self):
        '''
        Returns True is the selected thread is stopped at an exception
        '''
        return self.thread.stop_reason == lldb.eStopReasonException

    @memoized
    def getExceptionData(self):
        '''
        Returns up to three values. Exception Type as a string
        'EXC_BAD_ACCESS', Exception Code as a string (can be like '1'
        or like 'EXC_I386_GPFLT') and Extra as a string (can be an address
        '0x00000000' or a subcode '0x0')
        '''

        # EXC_BAD_ACCESS (code=2, address=0x100804000)
        # EXC_BAD_ACCESS (code=EXC_I386_GPFLT)
        # EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)
        if not self.isException:
            return None, None, None
        desc = self.getStopDescription().translate(None, '(),')
        if not (desc.startswith("EXC_") or desc.startswith("code=")):
            print "WARNING: Malformed exception description output %s" % desc
            return None, None, None
        fields = desc.split()
        exc = fields[0]
        code = fields[1].split("=", 2)[1]
        extra = None
        for f in fields:
            if f.startswith("address=") or f.startswith("subcode="):
                extra = f.split("=", 2)[1]
                break

        return [exc, code, extra]

    @memoized
    def getExceptionType(self):
        '''
        Returns the exception code as a string, or None
        '''
        e = self.getExceptionData()
        if e:
            return e[0]
        return None

    @memoized
    def isSignalInList(self, siglist):
        '''
        Returns True if target's signo is in siglist, False otherwise
        '''
        if not self.isSignal():
            return False
        tsigno = self.thread.GetStopReasonDataAtIndex(0)
        for s in siglist:
            signo = getattr(signal, s, None)  # not all sigs may be defined
            if signo and signo == tsigno:
                return True
        return False

    # TODO - wtf are they talking about here?
    #     //<rdar://problem/7930393> _dispatch_hardware_crash should use something other than __builtin_trap
    # if ([thread_log rangeOfString:@"\n0   libdispatch.dylib"].location != NSNotFound ||
    #     [thread_log rangeOfString:@"\n0   libxpc.dylib"].location != NSNotFound) {
    #   return CHANGE_TO_NOT_EXPLOITABLE;
    # }

    @memoized
    def isJumpInstruction(self, ins):
        '''
        Returns True if this is a valid jump or call
        '''
        # Unlike GDB, LLDB correctly considers calls branches, so no special
        # case required.
        return ins and ins.IsValid() and ins.DoesBranch()

    @memoized
    def faultingAddress(self):
        '''
        Returns the address causing an AV as an int or None
        '''
        if not self.isAv():
            return None

        # going to just handle the EXC_BAD_ACCESS case until I see a SIGSEGV
        exc, code, extra = self.getExceptionData()
        if exc == "EXC_BAD_ACCESS" and not code == "EXC_I386_GPFLT":
            try:
                return int(extra, 16)
            except:
                print "WARNING: Malformed exception data %s %s %s" % (desc, code, extra)
                return None
        # The GPFLT case will have to be special-cased higher up, because the
        # debugger will treat it as an address of 0x0, which would lead to
        # false-negative triage.
        return None

    @memoized
    def disasmAtPc(self, count=1):
        '''
        Returns a list of instructions at $pc ( one by default ). Returns None
        on error ( invalid $pc, incomplete disassembly )
        '''
        if not self.pc.IsValid():
            return None
        pc = self.pc.GetLoadAddress(self.target)
        return self.disasmAtAddress(pc, count)

    def disasmAtAddress(self, address, count=1):
        '''

        Take a uint64 ( or lldb::addr_t ), look it up as a virtual address and
        disassemble if possible, returning None on failure
        '''
        addr = self.lldbResolve(address)
        if not addr.IsValid:
            return None
        insns = self.target.ReadInstructions(addr, count)
        # TODO fancier handling of incomplete disassembly?
        if len(insns) < count:
            return None
        return insns

    @memoized
    def getRegisters(self, want=[]):
        '''
        Returns the general purpose registers and returns them as a
        map[string]uint64 or whatever you call that in python
        '''
        # get the registers
        registerSet = self.thread.GetFrameAtIndex(0).GetRegisters()
        # copied from the docs
        for regs in registerSet:
            if 'general purpose registers' in regs.GetName().lower():
                GPRs = regs
                break

        got = {}
        for reg in GPRs:
            if want == [] or reg.name in want:
                got[reg.name] = reg.GetValueAsUnsigned()

        return got

    @memoized
    def prettyRegisters(self):
        '''
        Returns an OrderedDict of x64 registers with values as hexstrings,
        formatted with colors where availble ( see GAC() ) 
        '''
        from collections import OrderedDict

        registers = OrderedDict()

        r = self.getRegisters()

        flags  = colored("O ", 'cyan') if (r['rflags'] >> 0xb) & 1 else "o "
        flags += colored("D ", 'cyan') if (r['rflags'] >> 0xa) & 1 else "d "
        flags += colored("I ", 'cyan') if (r['rflags'] >> 0x9) & 1 else "i "
        flags += colored("T ", 'cyan') if (r['rflags'] >> 0x8) & 1 else "t "
        flags += colored("S ", 'cyan') if (r['rflags'] >> 0x7) & 1 else "s "
        flags += colored("Z ", 'cyan') if (r['rflags'] >> 0x6) & 1 else "z "
        flags += colored("A ", 'cyan') if (r['rflags'] >> 0x5) & 1 else "a "
        flags += colored("P ", 'cyan') if (r['rflags'] >> 0x4) & 1 else "p "
        flags += colored("C ", 'cyan') if (r['rflags'] >> 0x3) & 1 else "c "

        for reg in ["rax", "rbx", "rcx", "rdx",
                    "rsi", "rdi",
                    "r8",  "r9", "r10", "r11", "r12", "r13", "r14", "r15",
                    "rsp", "rbp", "rip" ]:
            registers[reg] = self.GAC(r[reg])

        registers['flags'] = flags
        return registers

    @memoized
    def getCurrentInstruction(self):
        '''
        Returns the instruction at $pc in top frame of the current thread as
        an LLDB.SBInstruction
        '''
        d = self.disasmAtPc()
        if not d:
            return None
        return d[0]

    def lldbResolve(self, addr):
        '''
        Resolve a uint or lldb::addr_t as a section/offset address in the
        current target. Always returns an LLDB::SBAddress, which should be
        checked with IsValid() before use.
        '''
        return self.target.ResolveLoadAddress(addr)

    @memoized
    def getSPBP(self):
        '''
        Returns a (stack_pointer, base_pointer) tuple, suitable for multiple
        assignment or None, None on the off chance that they can't be retrieved.
        '''
        registers = self.getRegisters(['rbp', 'rsp'])
        if len(registers) < 2:
            # should probably panic about this
            return None, None
        return registers['rsp'], registers['rbp']
